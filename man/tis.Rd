% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tis.R
\name{tis}
\alias{tis}
\alias{tis.array}
\alias{tis.matrix}
\alias{tis.default}
\title{Truncated importance sampling (TIS)}
\usage{
tis(log_ratios, ...)

\method{tis}{array}(log_ratios, ..., r_eff = NULL, cores = getOption("mc.cores", 1))

\method{tis}{matrix}(log_ratios, ..., r_eff = NULL, cores = getOption("mc.cores", 1))

\method{tis}{default}(log_ratios, ..., r_eff = NULL)
}
\arguments{
\item{log_ratios}{An array, matrix, or vector of importance ratios on the log
scale (for Importance sampling LOO, these are \emph{negative} log-likelihood
values). See the \strong{Methods (by class)} section below for a detailed
description of how to specify the inputs for each method.}

\item{...}{Arguments passed on to the various methods.}

\item{r_eff}{Vector of relative effective sample size estimates containing
one element per observation. The values provided should be the relative
effective sample sizes of \code{1/exp(log_ratios)} (i.e., \code{1/ratios}).
This is related to the relative efficiency of estimating the normalizing
term in self-normalizing importance sampling. See the \code{\link[=relative_eff]{relative_eff()}}
helper function for computing \code{r_eff}. If using \code{psis} with
draws of the \code{log_ratios} not obtained from MCMC then the warning
message thrown when not specifying \code{r_eff} can be disabled by
setting \code{r_eff} to \code{NA}.}

\item{cores}{The number of cores to use for parallelization. This defaults to
the option \code{mc.cores} which can be set for an entire R session by
\code{options(mc.cores = NUMBER)}. The old option \code{loo.cores} is now
deprecated but will be given precedence over \code{mc.cores} until
\code{loo.cores} is removed in a future release. \strong{As of version
2.0.0 the default is now 1 core if \code{mc.cores} is not set}, but we
recommend using as many (or close to as many) cores as possible.
\itemize{
\item Note for Windows 10 users: it is \strong{strongly}
\href{https://github.com/stan-dev/loo/issues/94}{recommended} to avoid using
the \code{.Rprofile} file to set \code{mc.cores} (using the \code{cores} argument or
setting \code{mc.cores} interactively or in a script is fine).
}}
}
\value{
The \code{tis()} methods return an object of class \code{"tis"},
which is a named list with the following components:

\describe{
\item{\code{log_weights}}{
Vector or matrix of smoothed (and truncated) but \emph{unnormalized} log
weights. To get normalized weights use the
\code{\link[=weights.importance_sampling]{weights()}} method provided for objects of
class \code{tis}.
}
\item{\code{diagnostics}}{
A named list containing one vector:
\itemize{
\item \code{pareto_k}: Not used in \code{tis}, all set to 0.
\item \code{n_eff}: Effective sample size estimates.
}
}
}

Objects of class \code{"tis"} also have the following \link[=attributes]{attributes}:
\describe{
\item{\code{norm_const_log}}{
Vector of precomputed values of \code{colLogSumExps(log_weights)} that are
used internally by the \code{\link[=weights]{weights()}}method to normalize the log weights.
}
\item{\code{r_eff}}{
If specified, the user's \code{r_eff} argument.
}
\item{\code{tail_len}}{
Not used for \code{tis}.
}
\item{\code{dims}}{
Integer vector of length 2 containing \code{S} (posterior sample size)
and \code{N} (number of observations).
}
\item{\code{method}}{
Method used for importance sampling, here \code{tis}.
}
}
}
\description{
Implementation of truncated (self-normalized) importance sampling (TIS),
truncated at S^(1/2) as recommended by Ionides (2008).
}
\section{Methods (by class)}{
\itemize{
\item \code{tis(array)}: An \eqn{I} by \eqn{C} by \eqn{N} array, where \eqn{I}
is the number of MCMC iterations per chain, \eqn{C} is the number of
chains, and \eqn{N} is the number of data points.

\item \code{tis(matrix)}: An \eqn{S} by \eqn{N} matrix, where \eqn{S} is the size
of the posterior sample (with all chains merged) and \eqn{N} is the number
of data points.

\item \code{tis(default)}: A vector of length \eqn{S} (posterior sample size).

}}
\examples{
log_ratios <- -1 * example_loglik_array()
r_eff <- relative_eff(exp(-log_ratios))
tis_result <- tis(log_ratios, r_eff = r_eff)
str(tis_result)

# extract smoothed weights
lw <- weights(tis_result) # default args are log=TRUE, normalize=TRUE
ulw <- weights(tis_result, normalize=FALSE) # unnormalized log-weights

w <- weights(tis_result, log=FALSE) # normalized weights (not log-weights)
uw <- weights(tis_result, log=FALSE, normalize = FALSE) # unnormalized weights

}
\references{
Ionides, Edward L. (2008). Truncated importance sampling.
\emph{Journal of Computational and Graphical Statistics} 17(2): 295--311.
}
\seealso{
\itemize{
\item \code{\link[=psis]{psis()}} for approximate LOO-CV using PSIS.
\item \code{\link[=loo]{loo()}} for approximate LOO-CV.
\item \link{pareto-k-diagnostic} for PSIS diagnostics.
}
}

<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Leave-one-out cross-validation for non-factorized models • loo</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/cosmo/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Leave-one-out cross-validation for non-factorized models">
<meta property="og:description" content="loo">
<meta property="og:image" content="https://mc-stan.org/loo/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">loo</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">2.3.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/index.html">Vignettes</a>
</li>
<li>
  <a href="../reference/index.html">Functions</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Other Packages
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="https://mc-stan.org/rstan">rstan</a>
    </li>
    <li>
      <a href="https://mc-stan.org/cmdstanr">cmdstanr</a>
    </li>
    <li>
      <a href="https://mc-stan.org/rstanarm">rstanarm</a>
    </li>
    <li>
      <a href="https://mc-stan.org/bayesplot">bayesplot</a>
    </li>
    <li>
      <a href="https://mc-stan.org/shinystan">shinystan</a>
    </li>
    <li>
      <a href="https://mc-stan.org/projpred">projpred</a>
    </li>
    <li>
      <a href="https://mc-stan.org/rstantools">rstantools</a>
    </li>
    <li>
      <a href="https://mc-stan.org/posterior">posterior</a>
    </li>
  </ul>
</li>
<li>
  <a href="https://mc-stan.org">Stan</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://twitter.com/mcmc_stan">
    <span class="fa fa-twitter"></span>
     
  </a>
</li>
<li>
  <a href="https://github.com/stan-dev/loo">
    <span class="fa fa-github"></span>
     
  </a>
</li>
<li>
  <a href="https://discourse.mc-stan.org/">
    <span class="fa fa-users"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Leave-one-out cross-validation for non-factorized models</h1>
                        <h4 class="author">Aki Vehtari, Paul Bürkner and Jonah Gabry</h4>
            
            <h4 class="date">2020-07-07</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/stan-dev/loo/blob/master/vignettes/loo2-non-factorized.Rmd"><code>vignettes/loo2-non-factorized.Rmd</code></a></small>
      <div class="hidden name"><code>loo2-non-factorized.Rmd</code></div>

    </div>

    
    
<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{Leave-one-out cross-validation for non-factorized models}
-->
<div id="introduction" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h1>
<p>When computing ELPD-based LOO-CV for a Bayesian model we need to compute the log leave-one-out predictive densities <span class="math inline">\(\log{p(y_i | y_{-i})}\)</span> for every response value <span class="math inline">\(y_i, \: i = 1, \ldots, N\)</span>, where <span class="math inline">\(y_{-i}\)</span> denotes all response values except observation <span class="math inline">\(i\)</span>. To obtain <span class="math inline">\(p(y_i | y_{-i})\)</span>, we need to have access to the pointwise likelihood <span class="math inline">\(p(y_i\,|\, y_{-i}, \theta)\)</span> and integrate over the model parameters <span class="math inline">\(\theta\)</span>:</p>
<p><span class="math display">\[
p(y_i\,|\,y_{-i}) =
  \int p(y_i\,|\, y_{-i}, \theta) \, p(\theta\,|\, y_{-i}) \,d \theta
\]</span></p>
<p>Here, <span class="math inline">\(p(\theta\,|\, y_{-i})\)</span> is the leave-one-out posterior distribution for <span class="math inline">\(\theta\)</span>, that is, the posterior distribution for <span class="math inline">\(\theta\)</span> obtained by fitting the model while holding out the <span class="math inline">\(i\)</span>th observation (we will later show how refitting the model to data <span class="math inline">\(y_{-i}\)</span> can be avoided).</p>
<p>If the observation model is formulated directly as the product of the pointwise observation models, we call it a <em>factorized</em> model. In this case, the likelihood is also the product of the pointwise likelihood contributions <span class="math inline">\(p(y_i\,|\, y_{-i}, \theta)\)</span>. To better illustrate possible structures of the observation models, we formally divide <span class="math inline">\(\theta\)</span> into two parts, observation-specific latent variables <span class="math inline">\(f = (f_1, \ldots, f_N)\)</span> and hyperparameters <span class="math inline">\(\psi\)</span>, so that <span class="math inline">\(p(y_i\,|\, y_{-i}, \theta) = p(y_i\,|\, y_{-i}, f_i, \psi)\)</span>. Depending on the model, one of the two parts of <span class="math inline">\(\theta\)</span> may also be empty. In very simple models, such as linear regression models, latent variables are not explicitly presented and response values are conditionally independent given <span class="math inline">\(\psi\)</span>, so that <span class="math inline">\(p(y_i\,|\, y_{-i}, f_i, \psi) = p(y_i \,|\, \psi)\)</span>. The full likelihood can then be written in the familiar form</p>
<p><span class="math display">\[
p(y \,|\, \psi) = \prod_{i=1}^N p(y_i \,|\, \psi),
\]</span></p>
<p>where <span class="math inline">\(y = (y_1, \ldots, y_N)\)</span> denotes the vector of all responses. When the likelihood factorizes this way, the conditional pointwise log-likelihood can be obtained easily by computing <span class="math inline">\(p(y_i\,|\, \psi)\)</span> for each <span class="math inline">\(i\)</span> with computational cost <span class="math inline">\(O(n)\)</span>.</p>
<p>Yet, there are several reasons why a <em>non-factorized</em> observation model may be necessary or preferred. In non-factorized models, the joint likelihood of the response values <span class="math inline">\(p(y \,|\, \theta)\)</span> is not factorized into observation-specific components, but rather given directly as one joint expression. For some models, an analytic factorized formulation is simply not available in which case we speak of a <em>non-factorizable</em> model. Even in models whose observation model can be factorized in principle, it may still be preferable to use a non-factorized form for reasons of efficiency and numerical stability (Bürkner et al. 2020).</p>
<p>Whether a non-factorized model is used by necessity or for efficiency and stability, it comes at the cost of having no direct access to the leave-one-out predictive densities and thus to the overall leave-one-out predictive accuracy. In theory, we can express the observation-specific likelihoods in terms of the joint likelihood via</p>
<p><span class="math display">\[
p(y_i \,|\, y_{i-1}, \theta) =
  \frac{p(y \,|\, \theta)}{p(y_{-i} \,|\, \theta)} =
  \frac{p(y \,|\, \theta)}{\int p(y \,|\, \theta) \, d y_i},
\]</span></p>
<p>but the expression on the right-hand side may not always have an analytical solution. Computing <span class="math inline">\(\log p(y_i \,|\, y_{-i}, \theta)\)</span> for non-factorized models is therefore often impossible, or at least inefficient and numerically unstable. However, there is a large class of multivariate normal and Student-<span class="math inline">\(t\)</span> models for which there are efficient analytical solutions available.</p>
<p>More details can be found in our paper about LOO-CV for non-factorized models (Bürkner, Gabry, &amp; Vehtari, 2020), which is available as a preprint on arXiv (<a href="https://arxiv.org/abs/1810.10559" class="uri">https://arxiv.org/abs/1810.10559</a>).</p>
</div>
<div id="loo-cv-for-multivariate-normal-models" class="section level1">
<h1 class="hasAnchor">
<a href="#loo-cv-for-multivariate-normal-models" class="anchor"></a>LOO-CV for multivariate normal models</h1>
<p>In this vignette, we will focus on non-factorized multivariate normal models. Based on results of Sundararajan and Keerthi (2001), Bürkner et al. (2020) show that, for multivariate normal models with coriance matrix <span class="math inline">\(C\)</span>, the LOO predictive mean and standard deviation can be computed as follows:</p>
<p><span class="math display">\[\begin{align}
  \mu_{\tilde{y},-i} &amp;= y_i-\bar{c}_{ii}^{-1} g_i \nonumber \\
  \sigma_{\tilde{y},-i} &amp;= \sqrt{\bar{c}_{ii}^{-1}},
\end{align}\]</span></p>
<p>where <span class="math inline">\(g_i\)</span> and <span class="math inline">\(\bar{c}_{ii}\)</span> are</p>
<p><span class="math display">\[\begin{align}
  g_i &amp;= \left[C^{-1} y\right]_i \nonumber \\
  \bar{c}_{ii} &amp;= \left[C^{-1}\right]_{ii}.
\end{align}\]</span></p>
<p>Using these results, the log predictive density of the <span class="math inline">\(i\)</span>th observation is then computed as</p>
<p><span class="math display">\[
  \log p(y_i \,|\, y_{-i},\theta)
  = - \frac{1}{2}\log(2\pi)
  - \frac{1}{2}\log \sigma^2_{-i}
  - \frac{1}{2}\frac{(y_i-\mu_{-i})^2}{\sigma^2_{-i}}.
\]</span></p>
<p>Expressing this same equation in terms of <span class="math inline">\(g_i\)</span> and <span class="math inline">\(\bar{c}_{ii}\)</span>, the log predictive density becomes:</p>
<p><span class="math display">\[
  \log p(y_i \,|\, y_{-i},\theta)
  = - \frac{1}{2}\log(2\pi)
  + \frac{1}{2}\log \bar{c}_{ii}
  - \frac{1}{2}\frac{g_i^2}{\bar{c}_{ii}}.
\]</span> (Note that Vehtari et al. (2016) has a typo in the corresponding Equation 34.)</p>
<p>From these equations we can now derive a recipe for obtaining the conditional pointwise log-likelihood for <em>all</em> models that can be expressed conditionally in terms of a multivariate normal with invertible covariance matrix <span class="math inline">\(C\)</span>.</p>
<div id="approximate-loo-cv-using-integrated-importance-sampling" class="section level2">
<h2 class="hasAnchor">
<a href="#approximate-loo-cv-using-integrated-importance-sampling" class="anchor"></a>Approximate LOO-CV using integrated importance-sampling</h2>
<p>The above LOO equations for multivariate normal models are conditional on parameters <span class="math inline">\(\theta\)</span>. Therefore, to obtain the leave-one-out predictive density <span class="math inline">\(p(y_i \,|\, y_{-i})\)</span> we need to integrate over <span class="math inline">\(\theta\)</span>,</p>
<p><span class="math display">\[
p(y_i\,|\,y_{-i}) =
  \int p(y_i\,|\,y_{-i}, \theta) \, p(\theta\,|\,y_{-i}) \,d\theta.
\]</span></p>
<p>Here, <span class="math inline">\(p(\theta\,|\,y_{-i})\)</span> is the leave-one-out posterior distribution for <span class="math inline">\(\theta\)</span>, that is, the posterior distribution for <span class="math inline">\(\theta\)</span> obtained by fitting the model while holding out the <span class="math inline">\(i\)</span>th observation.</p>
<p>To avoid the cost of sampling from <span class="math inline">\(N\)</span> leave-one-out posteriors, it is possible to take the posterior draws <span class="math inline">\(\theta^{(s)}, \, s=1,\ldots,S\)</span>, from the  posterior <span class="math inline">\(p(\theta\,|\,y)\)</span>, and then approximate the above integral using integrated importance sampling (Vehtari et al., 2016, Section 3.6.1):</p>
<p><span class="math display">\[
 p(y_i\,|\,y_{-i}) \approx
   \frac{ \sum_{s=1}^S p(y_i\,|\,y_{-i},\,\theta^{(s)}) \,w_i^{(s)}}{ \sum_{s=1}^S w_i^{(s)}},
\]</span></p>
<p>where <span class="math inline">\(w_i^{(s)}\)</span> are importance weights. First we compute the raw importance ratios</p>
<p><span class="math display">\[
  r_i^{(s)} \propto \frac{1}{p(y_i \,|\, y_{-i}, \,\theta^{(s)})},
\]</span></p>
<p>and then stabilize them using Pareto smoothed importance sampling (PSIS, Vehtari et al, 2019) to obtain the weights <span class="math inline">\(w_i^{(s)}\)</span>. The resulting approximation is referred to as PSIS-LOO (Vehtari et al, 2017).</p>
</div>
<div id="exact-loo-cv-with-re-fitting" class="section level2">
<h2 class="hasAnchor">
<a href="#exact-loo-cv-with-re-fitting" class="anchor"></a>Exact LOO-CV with re-fitting</h2>
<p>In order to validate the approximate LOO procedure, and also in order to allow exact computations to be made for a small number of leave-one-out folds for which the Pareto <span class="math inline">\(k\)</span> diagnostic (Vehtari et al, 2019) indicates an unstable approximation, we need to consider how we might to do <em>exact</em> leave-one-out CV for a non-factorized model. In the case of a Gaussian process that has the marginalization property, we could just drop the one row and column of <span class="math inline">\(C\)</span> corresponding to the held out out observation. This does not hold in general for multivariate normal models, however, and to keep the original prior we may need to maintain the full covariance matrix <span class="math inline">\(C\)</span> even when one of the observations is left out.</p>
<p>The solution is to model <span class="math inline">\(y_i\)</span> as a missing observation and estimate it along with all of the other model parameters. For a conditional multivariate normal model, <span class="math inline">\(\log p(y_i\,|\,y_{-i})\)</span> can be computed as follows. First, we model <span class="math inline">\(y_i\)</span> as missing and denote the corresponding parameter <span class="math inline">\(y_i^{\mathrm{mis}}\)</span>. Then, we define</p>
<p><span class="math display">\[
y_{\mathrm{mis}(i)} = (y_1, \ldots, y_{i-1}, y_i^{\mathrm{mis}}, y_{i+1}, \ldots, y_N).
\]</span> to be the same as the full set of observations <span class="math inline">\(y\)</span>, except replacing <span class="math inline">\(y_i\)</span> with the parameter <span class="math inline">\(y_i^{\mathrm{mis}}\)</span>.</p>
<p>Second, we compute the LOO predictive mean and standard deviations as above, but replace <span class="math inline">\(y\)</span> with <span class="math inline">\(y_{\mathrm{mis}(i)}\)</span> in the computation of <span class="math inline">\(\mu_{\tilde{y},-i}\)</span>:</p>
<p><span class="math display">\[
\mu_{\tilde{y},-i} = y_{{\mathrm{mis}}(i)}-\bar{c}_{ii}^{-1}g_i,
\]</span></p>
<p>where in this case we have</p>
<p><span class="math display">\[
g_i = \left[ C^{-1} y_{\mathrm{mis}(i)} \right]_i.
\]</span></p>
<p>The conditional log predictive density is then computed with the above <span class="math inline">\(\mu_{\tilde{y},-i}\)</span> and the left out observation <span class="math inline">\(y_i\)</span>:</p>
<p><span class="math display">\[
  \log p(y_i\,|\,y_{-i},\theta)
  = - \frac{1}{2}\log(2\pi)
  - \frac{1}{2}\log \sigma^2_{\tilde{y},-i}
  - \frac{1}{2}\frac{(y_i-\mu_{\tilde{y},-i})^2}{\sigma^2_{\tilde{y},-i}}.
\]</span></p>
<p>Finally, the leave-one-out predictive distribution can then be estimated as</p>
<p><span class="math display">\[
 p(y_i\,|\,y_{-i}) \approx \sum_{s=1}^S p(y_i\,|\,y_{-i}, \theta_{-i}^{(s)}),
\]</span></p>
<p>where <span class="math inline">\(\theta_{-i}^{(s)}\)</span> are draws from the posterior distribution <span class="math inline">\(p(\theta\,|\,y_{\mathrm{mis}(i)})\)</span>.</p>
</div>
</div>
<div id="lagged-sar-models" class="section level1">
<h1 class="hasAnchor">
<a href="#lagged-sar-models" class="anchor"></a>Lagged SAR models</h1>
<p>A common non-factorized multivariate normal model is the simultaneously autoregressive (SAR) model, which is frequently used for spatially correlated data. The lagged SAR model is defined as</p>
<p><span class="math display">\[
y = \rho Wy + \eta + \epsilon
\]</span> or equivalently <span class="math display">\[
(I - \rho W)y = \eta + \epsilon,
\]</span> where <span class="math inline">\(\rho\)</span> is the spatial correlation parameter and <span class="math inline">\(W\)</span> is a user-defined weight matrix. The matrix <span class="math inline">\(W\)</span> has entries <span class="math inline">\(w_{ii} = 0\)</span> along the diagonal and the off-diagonal entries <span class="math inline">\(w_{ij}\)</span> are larger when areas <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are closer to each other. In a linear model, the predictor term <span class="math inline">\(\eta\)</span> is given by <span class="math inline">\(\eta = X \beta\)</span> with design matrix <span class="math inline">\(X\)</span> and regression coefficients <span class="math inline">\(\beta\)</span>. However, since the above equation holds for arbitrary <span class="math inline">\(\eta\)</span>, these results are not restricted to linear models.</p>
<p>If we have <span class="math inline">\(\epsilon \sim {\mathrm N}(0, \,\sigma^2 I)\)</span>, it follows that <span class="math display">\[
(I - \rho W)y \sim {\mathrm N}(\eta, \sigma^2 I),
\]</span> which corresponds to the following log PDF coded in <strong>Stan</strong>:</p>
<div class="sourceCode" id="cb1"><html><body><pre class="r">/**
 * Normal log-pdf for spatially lagged responses
 *
 * @param y Vector of response values.
 * @param mu Mean parameter vector.
 * @param sigma Positive scalar residual standard deviation.
 * @param rho Positive scalar autoregressive parameter.
 * @param W Spatial weight matrix.
 *
 * @return A scalar to be added to the log posterior.
 */
real normal_lagsar_lpdf(vector y, vector mu, real sigma,
                        real rho, matrix W) {
  int N = rows(y);
  real inv_sigma2 = 1 / square(sigma);
  matrix[N, N] W_tilde = -rho * W;
  vector[N] half_pred;

  for (n in 1:N) W_tilde[n,n] += 1;

  half_pred = W_tilde * (y - mdivide_left(W_tilde, mu));

  return 0.5 * log_determinant(crossprod(W_tilde) * inv_sigma2) -
         0.5 * dot_self(half_pred) * inv_sigma2;
}</pre></body></html></div>
<p>For the purpose of computing LOO-CV, it makes sense to rewrite the SAR model in slightly different form. Conditional on <span class="math inline">\(\rho\)</span>, <span class="math inline">\(\eta\)</span>, and <span class="math inline">\(\sigma\)</span>, if we write</p>
<p><span class="math display">\[\begin{align}
y-(I-\rho W)^{-1}\eta &amp;\sim {\mathrm N}(0, \sigma^2(I-\rho W)^{-1}(I-\rho W)^{-T}),
\end{align}\]</span></p>
<p>or more compactly, with <span class="math inline">\(\widetilde{W}=(I-\rho W)\)</span>,</p>
<p><span class="math display">\[\begin{align}
y-\widetilde{W}^{-1}\eta &amp;\sim {\mathrm N}(0, \sigma^2(\widetilde{W}^{T}\widetilde{W})^{-1}),
\end{align}\]</span></p>
<p>then this has the same form as the zero mean Gaussian process from above. Accordingly, we can compute the leave-one-out predictive densities with the equations from Sundararajan and Keerthi (2001), replacing <span class="math inline">\(y\)</span> with <span class="math inline">\((y-\widetilde{W}^{-1}\eta)\)</span> and taking the covariance matrix <span class="math inline">\(C\)</span> to be <span class="math inline">\(\sigma^2(\widetilde{W}^{T}\widetilde{W})^{-1}\)</span>.</p>
<div id="case-study-neighborhood-crime-in-columbus-ohio" class="section level2">
<h2 class="hasAnchor">
<a href="#case-study-neighborhood-crime-in-columbus-ohio" class="anchor"></a>Case Study: Neighborhood Crime in Columbus, Ohio</h2>
<p>In order to demonstrate how to carry out the computations implied by these equations, we will first fit a lagged SAR model to data on crime in 49 different neighborhoods of Columbus, Ohio during the year 1980. The data was originally described in Aneslin (1988) and ships with the <strong>spdep</strong> R package.</p>
<p>In addition to the <strong>loo</strong> package, for this analysis we will use the <strong>brms</strong> interface to Stan to generate a Stan program and fit the model, and also the <strong>bayesplot</strong> and <strong>ggplot2</strong> packages for plotting.</p>
<div class="sourceCode" id="cb2"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="st">"loo"</span>)
<span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="st">"brms"</span>)
<span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="st">"bayesplot"</span>)
<span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="st">"ggplot2"</span>)
<span class="fu"><a href="https://mc-stan.org/bayesplot/reference/bayesplot-colors.html">color_scheme_set</a></span>(<span class="st">"brightblue"</span>)
<span class="fu"><a href="https://ggplot2.tidyverse.org/reference/theme_get.html">theme_set</a></span>(<span class="fu"><a href="https://rdrr.io/pkg/brms/man/theme_default.html">theme_default</a></span>())


<span class="no">SEED</span> <span class="kw">&lt;-</span> <span class="fl">10001</span>
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span>(<span class="no">SEED</span>) <span class="co"># only sets seed for R (seed for Stan set later)</span>

<span class="co"># loads COL.OLD data frame and COL.nb neighbor list</span>
<span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span>(<span class="no">oldcol</span>, <span class="kw">package</span> <span class="kw">=</span> <span class="st">"spdep"</span>)</pre></body></html></div>
<p>The three variables in the data set relevant to this example are:</p>
<ul>
<li>
<code>CRIME</code>: the number of residential burglaries and vehicle thefts per thousand households in the neighbood</li>
<li>
<code>HOVAL</code>: housing value in units of $1000 USD</li>
<li>
<code>INC</code>: household income in units of $1000 USD</li>
</ul>
<div class="sourceCode" id="cb3"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span>(<span class="no">COL.OLD</span>[, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"CRIME"</span>, <span class="st">"HOVAL"</span>, <span class="st">"INC"</span>)])</pre></body></html></div>
<pre><code>'data.frame':   49 obs. of  3 variables:
 $ CRIME: num  18.802 32.388 38.426 0.178 15.726 ...
 $ HOVAL: num  44.6 33.2 37.1 75 80.5 ...
 $ INC  : num  21.23 4.48 11.34 8.44 19.53 ...</code></pre>
<p>We will also use the object <code>COL.nb</code>, which is a list containing information about which neighborhoods border each other. From this list we will be able to construct the weight matrix to used to help account for the spatial dependency among the observations.</p>
<div id="fit-lagged-sar-model" class="section level3">
<h3 class="hasAnchor">
<a href="#fit-lagged-sar-model" class="anchor"></a>Fit lagged SAR model</h3>
<p>A model predicting <code>CRIME</code> from <code>INC</code> and <code>HOVAL</code>, while accounting for the spatial dependency via an SAR structure, can be specified in <strong>brms</strong> as follows.</p>
<div class="sourceCode" id="cb5"><html><body><pre class="r"><span class="no">fit</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/brms/man/brm.html">brm</a></span>(
  <span class="no">CRIME</span> ~ <span class="no">INC</span> + <span class="no">HOVAL</span> + <span class="fu"><a href="https://rdrr.io/pkg/brms/man/sar.html">sar</a></span>(<span class="no">COL.nb</span>, <span class="kw">type</span> <span class="kw">=</span> <span class="st">"lag"</span>),
  <span class="kw">data</span> <span class="kw">=</span> <span class="no">COL.OLD</span>,
  <span class="kw">data2</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">COL.nb</span> <span class="kw">=</span> <span class="no">COL.nb</span>),
  <span class="kw">chains</span> <span class="kw">=</span> <span class="fl">4</span>,
  <span class="kw">seed</span> <span class="kw">=</span> <span class="no">SEED</span>
)</pre></body></html></div>
<p>The code above fits the model in <strong>Stan</strong> using a log PDF equivalent to the <code>normal_lagsar_lpdf</code> function we defined above. In the summary output below we see that both higher income and higher housing value predict lower crime rates in the neighborhood. Moreover, there seems to be substantial spatial correlation between adjacent neighborhoods, as indicated by the posterior distribution of the <code>lagsar</code> parameter.</p>
<div class="sourceCode" id="cb6"><html><body><pre class="r"><span class="no">lagsar</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span>(<span class="no">fit</span>, <span class="kw">pars</span> <span class="kw">=</span> <span class="st">"lagsar"</span>)
<span class="no">estimates</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/quantile.html">quantile</a></span>(<span class="no">lagsar</span>, <span class="kw">probs</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="fl">0.75</span>))
<span class="fu"><a href="https://mc-stan.org/bayesplot/reference/MCMC-distributions.html">mcmc_hist</a></span>(<span class="no">lagsar</span>) +
  <span class="fu"><a href="https://mc-stan.org/bayesplot/reference/bayesplot-helpers.html">vline_at</a></span>(<span class="no">estimates</span>, <span class="kw">linetype</span> <span class="kw">=</span> <span class="fl">2</span>, <span class="kw">size</span> <span class="kw">=</span> <span class="fl">1</span>) +
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html">ggtitle</a></span>(<span class="st">"lagsar: posterior median and 50% central interval"</span>)</pre></body></html></div>
<p><img src="loo2-non-factorized_files/figure-html/lagsar-1.png" width="60%" style="display: block; margin: auto;"></p>
</div>
<div id="approximate-loo-cv" class="section level3">
<h3 class="hasAnchor">
<a href="#approximate-loo-cv" class="anchor"></a>Approximate LOO-CV</h3>
<p>After fitting the model, the next step is to compute the pointwise log-likelihood values needed for approximate LOO-CV. To do this we will use the recipe laid out in the previous sections.</p>
<div class="sourceCode" id="cb7"><html><body><pre class="r"><span class="no">posterior</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html">as.data.frame</a></span>(<span class="no">fit</span>)
<span class="no">y</span> <span class="kw">&lt;-</span> <span class="no">fit</span>$<span class="no">data</span>$<span class="no">CRIME</span>
<span class="no">N</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span>(<span class="no">y</span>)
<span class="no">S</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span>(<span class="no">posterior</span>)
<span class="no">loglik</span> <span class="kw">&lt;-</span> <span class="no">yloo</span> <span class="kw">&lt;-</span> <span class="no">sdloo</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="kw">nrow</span> <span class="kw">=</span> <span class="no">S</span>, <span class="kw">ncol</span> <span class="kw">=</span> <span class="no">N</span>)

<span class="kw">for</span> (<span class="no">s</span> <span class="kw">in</span> <span class="fl">1</span>:<span class="no">S</span>) {
  <span class="no">p</span> <span class="kw">&lt;-</span> <span class="no">posterior</span>[<span class="no">s</span>, ]
  <span class="no">eta</span> <span class="kw">&lt;-</span> <span class="no">p</span>$<span class="no">b_Intercept</span> + <span class="no">p</span>$<span class="no">b_INC</span> * <span class="no">fit</span>$<span class="no">data</span>$<span class="no">INC</span> + <span class="no">p</span>$<span class="no">b_HOVAL</span> * <span class="no">fit</span>$<span class="no">data</span>$<span class="no">HOVAL</span>
  <span class="no">W_tilde</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="no">N</span>) - <span class="no">p</span>$<span class="no">lagsar</span> * <span class="kw pkg">spdep</span><span class="kw ns">::</span><span class="fu"><a href="https://rdrr.io/pkg/spdep/man/nb2mat.html">nb2mat</a></span>(<span class="no">COL.nb</span>)
  <span class="no">Cinv</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="no">W_tilde</span>) <span class="kw">%*%</span> <span class="no">W_tilde</span> / <span class="no">p</span>$<span class="no">sigma</span>^<span class="fl">2</span>
  <span class="no">g</span> <span class="kw">&lt;-</span> <span class="no">Cinv</span> <span class="kw">%*%</span> (<span class="no">y</span> - <span class="fu"><a href="https://rdrr.io/r/base/solve.html">solve</a></span>(<span class="no">W_tilde</span>, <span class="no">eta</span>))
  <span class="no">cbar</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="no">Cinv</span>)
  <span class="no">yloo</span>[<span class="no">s</span>, ] <span class="kw">&lt;-</span> <span class="no">y</span> - <span class="no">g</span> / <span class="no">cbar</span>
  <span class="no">sdloo</span>[<span class="no">s</span>, ] <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span>(<span class="fl">1</span> / <span class="no">cbar</span>)
  <span class="no">loglik</span>[<span class="no">s</span>, ] <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">y</span>, <span class="no">yloo</span>[<span class="no">s</span>, ], <span class="no">sdloo</span>[<span class="no">s</span>, ], <span class="kw">log</span> <span class="kw">=</span> <span class="fl">TRUE</span>)
}

<span class="co"># use loo for psis smoothing</span>
<span class="no">log_ratios</span> <span class="kw">&lt;-</span> -<span class="no">loglik</span>
<span class="no">psis_result</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/psis.html">psis</a></span>(<span class="no">log_ratios</span>)</pre></body></html></div>
<p>The quality of the PSIS-LOO approximation can be investigated graphically by plotting the Pareto-k estimate for each observation. Ideally, they should not exceed <span class="math inline">\(0.5\)</span>, but in practice the algorithm turns out to be robust up to values of <span class="math inline">\(0.7\)</span> (Vehtari et al, 2017, 2019). In the plot below, we see that the fourth observation is problematic and so may reduce the accuracy of the LOO-CV approximation.</p>
<div class="sourceCode" id="cb8"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.html">plot</a></span>(<span class="no">psis_result</span>, <span class="kw">label_points</span> <span class="kw">=</span> <span class="fl">TRUE</span>)</pre></body></html></div>
<p><img src="loo2-non-factorized_files/figure-html/plot-1.png" width="60%" style="display: block; margin: auto;"></p>
<p>We can also check that the conditional leave-one-out predictive distribution equations work correctly, for instance, using the last posterior draw:</p>
<div class="sourceCode" id="cb9"><html><body><pre class="r"><span class="no">yloo_sub</span> <span class="kw">&lt;-</span> <span class="no">yloo</span>[<span class="no">S</span>, ]
<span class="no">sdloo_sub</span> <span class="kw">&lt;-</span> <span class="no">sdloo</span>[<span class="no">S</span>, ]
<span class="no">df</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(
  <span class="kw">y</span> <span class="kw">=</span> <span class="no">y</span>,
  <span class="kw">yloo</span> <span class="kw">=</span> <span class="no">yloo_sub</span>,
  <span class="kw">ymin</span> <span class="kw">=</span> <span class="no">yloo_sub</span> - <span class="no">sdloo_sub</span> * <span class="fl">2</span>,
  <span class="kw">ymax</span> <span class="kw">=</span> <span class="no">yloo_sub</span> + <span class="no">sdloo_sub</span> * <span class="fl">2</span>
)
<span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span>(<span class="kw">data</span><span class="kw">=</span><span class="no">df</span>, <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span>(<span class="kw">x</span> <span class="kw">=</span> <span class="no">y</span>, <span class="kw">y</span> <span class="kw">=</span> <span class="no">yloo</span>, <span class="kw">ymin</span> <span class="kw">=</span> <span class="no">ymin</span>, <span class="kw">ymax</span> <span class="kw">=</span> <span class="no">ymax</span>)) +
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_linerange.html">geom_errorbar</a></span>(
    <span class="kw">width</span> <span class="kw">=</span> <span class="fl">1</span>,
    <span class="kw">color</span> <span class="kw">=</span> <span class="st">"skyblue3"</span>,
    <span class="kw">position</span> <span class="kw">=</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/position_jitter.html">position_jitter</a></span>(<span class="kw">width</span> <span class="kw">=</span> <span class="fl">0.25</span>)
  ) +
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_abline.html">geom_abline</a></span>(<span class="kw">color</span> <span class="kw">=</span> <span class="st">"gray30"</span>, <span class="kw">size</span> <span class="kw">=</span> <span class="fl">1.2</span>) +
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html">geom_point</a></span>()</pre></body></html></div>
<p><img src="loo2-non-factorized_files/figure-html/checklast-1.png" width="60%" style="display: block; margin: auto;"></p>
<p>Finally, we use PSIS-LOO to approximate the expected log predictive density (ELPD) for new data, which we will validate using exact LOO-CV in the upcoming section.</p>
<div class="sourceCode" id="cb10"><html><body><pre class="r">(<span class="no">psis_loo</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/loo.html">loo</a></span>(<span class="no">loglik</span>))</pre></body></html></div>
<pre><code>
Computed from 4000 by 49 log-likelihood matrix

         Estimate   SE
elpd_loo   -186.7 10.6
p_loo         7.9  5.0
looic       373.4 21.2
------
Monte Carlo SE of elpd_loo is NA.

Pareto k diagnostic values:
                         Count Pct.    Min. n_eff
(-Inf, 0.5]   (good)     47    95.9%   2439      
 (0.5, 0.7]   (ok)        1     2.0%   532       
   (0.7, 1]   (bad)       0     0.0%   &lt;NA&gt;      
   (1, Inf)   (very bad)  1     2.0%   38        
See help('pareto-k-diagnostic') for details.</code></pre>
</div>
<div id="exact-loo-cv" class="section level3">
<h3 class="hasAnchor">
<a href="#exact-loo-cv" class="anchor"></a>Exact LOO-CV</h3>
<p>Exact LOO-CV for the above example is somewhat more involved, as we need to re-fit the model <span class="math inline">\(N\)</span> times and each time model the held-out data point as a parameter. First, we create an empty dummy model that we will update below as we loop over the observations.</p>
<div class="sourceCode" id="cb12"><html><body><pre class="r"><span class="co"># see help("mi", "brms") for details on the mi() usage</span>
<span class="no">fit_dummy</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/brms/man/brm.html">brm</a></span>(
  <span class="no">CRIME</span> <span class="kw">|</span> <span class="fu"><a href="https://rdrr.io/pkg/brms/man/mi.html">mi</a></span>() ~ <span class="no">INC</span> + <span class="no">HOVAL</span> + <span class="fu"><a href="https://rdrr.io/pkg/brms/man/sar.html">sar</a></span>(<span class="no">COL.nb</span>, <span class="kw">type</span> <span class="kw">=</span> <span class="st">"lag"</span>),
  <span class="kw">data</span> <span class="kw">=</span> <span class="no">COL.OLD</span>,
  <span class="kw">data2</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">COL.nb</span> <span class="kw">=</span> <span class="no">COL.nb</span>),
  <span class="kw">chains</span> <span class="kw">=</span> <span class="fl">0</span>
)</pre></body></html></div>
<pre><code>Running /Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB foo.c
clang -I"/Library/Frameworks/R.framework/Resources/include" -DNDEBUG   -I"/Library/Frameworks/R.framework/Versions/3.6/Resources/library/Rcpp/include/"  -I"/Library/Frameworks/R.framework/Versions/3.6/Resources/library/RcppEigen/include/"  -I"/Library/Frameworks/R.framework/Versions/3.6/Resources/library/RcppEigen/include/unsupported"  -I"/Library/Frameworks/R.framework/Versions/3.6/Resources/library/BH/include" -I"/Library/Frameworks/R.framework/Versions/3.6/Resources/library/StanHeaders/include/src/"  -I"/Library/Frameworks/R.framework/Versions/3.6/Resources/library/StanHeaders/include/"  -I"/Library/Frameworks/R.framework/Versions/3.6/Resources/library/rstan/include" -DEIGEN_NO_DEBUG  -D_REENTRANT  -DBOOST_DISABLE_ASSERTS -DBOOST_PENDING_INTEGER_LOG2_HPP -include stan/math/prim/mat/fun/Eigen.hpp   -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk -I/usr/local/include  -fPIC  -Wall -g -O2  -c foo.c -o foo.o
In file included from &lt;built-in&gt;:1:
In file included from /Library/Frameworks/R.framework/Versions/3.6/Resources/library/StanHeaders/include/stan/math/prim/mat/fun/Eigen.hpp:4:
In file included from /Library/Frameworks/R.framework/Versions/3.6/Resources/library/RcppEigen/include/Eigen/Dense:1:
In file included from /Library/Frameworks/R.framework/Versions/3.6/Resources/library/RcppEigen/include/Eigen/Core:88:
/Library/Frameworks/R.framework/Versions/3.6/Resources/library/RcppEigen/include/Eigen/src/Core/util/Macros.h:613:1: error: unknown type name 'namespace'
namespace Eigen {
^
/Library/Frameworks/R.framework/Versions/3.6/Resources/library/RcppEigen/include/Eigen/src/Core/util/Macros.h:613:16: error: expected ';' after top level declarator
namespace Eigen {
               ^
               ;
In file included from &lt;built-in&gt;:1:
In file included from /Library/Frameworks/R.framework/Versions/3.6/Resources/library/StanHeaders/include/stan/math/prim/mat/fun/Eigen.hpp:4:
In file included from /Library/Frameworks/R.framework/Versions/3.6/Resources/library/RcppEigen/include/Eigen/Dense:1:
/Library/Frameworks/R.framework/Versions/3.6/Resources/library/RcppEigen/include/Eigen/Core:96:10: fatal error: 'complex' file not found
#include &lt;complex&gt;
         ^~~~~~~~~
3 errors generated.
make: *** [foo.o] Error 1</code></pre>
<p>Next, we fit the model <span class="math inline">\(N\)</span> times, each time leaving out a single observation and then computing the log predictive density for that observation. For obvious reasons, this takes much longer than the approximation we computed above, but it is necessary in order to validate the approximate LOO-CV method. Thanks to the PSIS-LOO approximation, in general doing these slow exact computations can be avoided.</p>
<div class="sourceCode" id="cb14"><html><body><pre class="r"><span class="no">S</span> <span class="kw">&lt;-</span> <span class="fl">500</span>
<span class="no">res</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span>(<span class="st">"list"</span>, <span class="no">N</span>)
<span class="no">loglik</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="kw">nrow</span> <span class="kw">=</span> <span class="no">S</span>, <span class="kw">ncol</span> <span class="kw">=</span> <span class="no">N</span>)
<span class="kw">for</span> (<span class="no">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq_len</a></span>(<span class="no">N</span>)) {
  <span class="no">dat_mi</span> <span class="kw">&lt;-</span> <span class="no">COL.OLD</span>
  <span class="no">dat_mi</span>$<span class="no">CRIME</span>[<span class="no">i</span>] <span class="kw">&lt;-</span> <span class="fl">NA</span>
  <span class="no">fit_i</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/update.html">update</a></span>(<span class="no">fit_dummy</span>, <span class="kw">newdata</span> <span class="kw">=</span> <span class="no">dat_mi</span>,
                  <span class="co"># just for vignette</span>
                  <span class="kw">chains</span> <span class="kw">=</span> <span class="fl">1</span>, <span class="kw">iter</span> <span class="kw">=</span> <span class="no">S</span> * <span class="fl">2</span>)
  <span class="no">posterior</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html">as.data.frame</a></span>(<span class="no">fit_i</span>)
  <span class="no">yloo</span> <span class="kw">&lt;-</span> <span class="no">sdloo</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="fl">NA</span>, <span class="no">S</span>)
  <span class="kw">for</span> (<span class="no">s</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq_len</a></span>(<span class="no">S</span>)) {
    <span class="no">p</span> <span class="kw">&lt;-</span> <span class="no">posterior</span>[<span class="no">s</span>, ]
    <span class="no">y_miss_i</span> <span class="kw">&lt;-</span> <span class="no">y</span>
    <span class="no">y_miss_i</span>[<span class="no">i</span>] <span class="kw">&lt;-</span> <span class="no">p</span>$<span class="no">Ymi</span>
    <span class="no">eta</span> <span class="kw">&lt;-</span> <span class="no">p</span>$<span class="no">b_Intercept</span> + <span class="no">p</span>$<span class="no">b_INC</span> * <span class="no">fit_i</span>$<span class="no">data</span>$<span class="no">INC</span> + <span class="no">p</span>$<span class="no">b_HOVAL</span> * <span class="no">fit_i</span>$<span class="no">data</span>$<span class="no">HOVAL</span>
    <span class="no">W_tilde</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="no">N</span>) - <span class="no">p</span>$<span class="no">lagsar</span> * <span class="kw pkg">spdep</span><span class="kw ns">::</span><span class="fu"><a href="https://rdrr.io/pkg/spdep/man/nb2mat.html">nb2mat</a></span>(<span class="no">COL.nb</span>)
    <span class="no">Cinv</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="no">W_tilde</span>) <span class="kw">%*%</span> <span class="no">W_tilde</span> / <span class="no">p</span>$<span class="no">sigma</span>^<span class="fl">2</span>
    <span class="no">g</span> <span class="kw">&lt;-</span> <span class="no">Cinv</span> <span class="kw">%*%</span> (<span class="no">y_miss_i</span> - <span class="fu"><a href="https://rdrr.io/r/base/solve.html">solve</a></span>(<span class="no">W_tilde</span>, <span class="no">eta</span>))
    <span class="no">cbar</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="no">Cinv</span>);
    <span class="no">yloo</span>[<span class="no">s</span>] <span class="kw">&lt;-</span> <span class="no">y_miss_i</span>[<span class="no">i</span>] - <span class="no">g</span>[<span class="no">i</span>] / <span class="no">cbar</span>[<span class="no">i</span>]
    <span class="no">sdloo</span>[<span class="no">s</span>] <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span>(<span class="fl">1</span> / <span class="no">cbar</span>[<span class="no">i</span>])
    <span class="no">loglik</span>[<span class="no">s</span>, <span class="no">i</span>] <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">y</span>[<span class="no">i</span>], <span class="no">yloo</span>[<span class="no">s</span>], <span class="no">sdloo</span>[<span class="no">s</span>], <span class="kw">log</span> <span class="kw">=</span> <span class="fl">TRUE</span>)
  }
  <span class="no">ypred</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span>(<span class="no">S</span>, <span class="no">yloo</span>, <span class="no">sdloo</span>)
  <span class="no">res</span><span class="kw">[[</span><span class="no">i</span>]] <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(<span class="kw">y</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="no">posterior</span>$<span class="no">Ymi</span>, <span class="no">ypred</span>))
  <span class="no">res</span><span class="kw">[[</span><span class="no">i</span>]]$<span class="no">type</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"pp"</span>, <span class="st">"loo"</span>), <span class="kw">each</span> <span class="kw">=</span> <span class="no">S</span>)
  <span class="no">res</span><span class="kw">[[</span><span class="no">i</span>]]$<span class="no">obs</span> <span class="kw">&lt;-</span> <span class="no">i</span>
}
<span class="no">res</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/do.call.html">do.call</a></span>(<span class="no">rbind</span>, <span class="no">res</span>)</pre></body></html></div>
<p>A first step in the validation of the pointwise predictive density is to compare the distribution of the implied response values for the left-out observation to the distribution of the <span class="math inline">\(y_i^{\mathrm{mis}}\)</span> posterior-predictive values estimated as part of the model. If the pointwise predictive density is correct, the two distributions should match very closely (up to sampling error). In the plot below, we overlay these two distributions for the first four observations and see that they match very closely (as is the case for all <span class="math inline">\(49\)</span> observations of in this example).</p>
<div class="sourceCode" id="cb15"><html><body><pre class="r"><span class="no">res_sub</span> <span class="kw">&lt;-</span> <span class="no">res</span>[<span class="no">res</span>$<span class="no">obs</span> <span class="kw">%in%</span> <span class="fl">1</span>:<span class="fl">4</span>, ]
<span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span>(<span class="no">res_sub</span>, <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span>(<span class="no">y</span>, <span class="kw">fill</span> <span class="kw">=</span> <span class="no">type</span>)) +
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_density.html">geom_density</a></span>(<span class="kw">alpha</span> <span class="kw">=</span> <span class="fl">0.6</span>) +
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/facet_wrap.html">facet_wrap</a></span>(<span class="st">"obs"</span>, <span class="kw">scales</span> <span class="kw">=</span> <span class="st">"fixed"</span>, <span class="kw">ncol</span> <span class="kw">=</span> <span class="fl">4</span>)</pre></body></html></div>
<p><img src="loo2-non-factorized_files/figure-html/yplots-1.png" width="95%" style="display: block; margin: auto;"></p>
<p>In the final step, we compute the ELPD based on the exact LOO-CV and compare it to the approximate PSIS-LOO result computed earlier.</p>
<div class="sourceCode" id="cb16"><html><body><pre class="r"><span class="no">log_mean_exp</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">x</span>) {
  <span class="co"># more stable than log(mean(exp(x)))</span>
  <span class="no">max_x</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span>(<span class="no">x</span>)
  <span class="no">max_x</span> + <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="no">x</span> - <span class="no">max_x</span>))) - <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span>(<span class="no">x</span>))
}
<span class="no">exact_elpds</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span>(<span class="no">loglik</span>, <span class="fl">2</span>, <span class="no">log_mean_exp</span>)
<span class="no">exact_elpd</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">exact_elpds</span>)
<span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span>(<span class="no">exact_elpd</span>, <span class="fl">1</span>)</pre></body></html></div>
<pre><code>[1] -188.4</code></pre>
<p>The results of the approximate and exact LOO-CV are similar but not as close as we would expect if there were no problematic observations. We can investigate this issue more closely by plotting the approximate against the exact pointwise ELPD values.</p>
<div class="sourceCode" id="cb18"><html><body><pre class="r"><span class="no">df</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(
  <span class="kw">approx_elpd</span> <span class="kw">=</span> <span class="no">psis_loo</span>$<span class="no">pointwise</span>[, <span class="st">"elpd_loo"</span>],
  <span class="kw">exact_elpd</span> <span class="kw">=</span> <span class="no">exact_elpds</span>
)
<span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span>(<span class="no">df</span>, <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span>(<span class="kw">x</span> <span class="kw">=</span> <span class="no">approx_elpd</span>, <span class="kw">y</span> <span class="kw">=</span> <span class="no">exact_elpd</span>)) +
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_abline.html">geom_abline</a></span>(<span class="kw">color</span> <span class="kw">=</span> <span class="st">"gray30"</span>) +
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html">geom_point</a></span>(<span class="kw">size</span> <span class="kw">=</span> <span class="fl">2</span>) +
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html">geom_point</a></span>(<span class="kw">data</span> <span class="kw">=</span> <span class="no">df</span>[<span class="fl">4</span>, ], <span class="kw">size</span> <span class="kw">=</span> <span class="fl">2</span>, <span class="kw">color</span> <span class="kw">=</span> <span class="st">"red3"</span>) +
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html">xlab</a></span>(<span class="st">"Approximate elpds"</span>) +
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html">ylab</a></span>(<span class="st">"Exact elpds"</span>) +
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/coord_fixed.html">coord_fixed</a></span>(<span class="kw">xlim</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(-<span class="fl">16</span>, -<span class="fl">3</span>), <span class="kw">ylim</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(-<span class="fl">16</span>, -<span class="fl">3</span>))</pre></body></html></div>
<p><img src="loo2-non-factorized_files/figure-html/compare-1.png" width="60%" style="display: block; margin: auto;"></p>
<p>In the plot above the fourth data point —the observation flagged as problematic by the PSIS-LOO approximation— is colored in red and is the clear outlier. Otherwise, the correspondence between the exact and approximate values is strong. In fact, summing over the pointwise ELPD values and leaving out the fourth observation yields practically equivalent results for approximate and exact LOO-CV:</p>
<div class="sourceCode" id="cb19"><html><body><pre class="r"><span class="no">without_pt_4</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(
  <span class="kw">approx</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">psis_loo</span>$<span class="no">pointwise</span>[-<span class="fl">4</span>, <span class="st">"elpd_loo"</span>]),
  <span class="kw">exact</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">exact_elpds</span>[-<span class="fl">4</span>])
)
<span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span>(<span class="no">without_pt_4</span>, <span class="fl">2</span>)</pre></body></html></div>
<pre><code> approx   exact 
-173.06 -173.12 </code></pre>
<p>From this we can conclude that the difference we found when including <em>all</em> observations does not indicate a bug in our implementation of the approximate LOO-CV but rather a violation of its assumptions.</p>
</div>
</div>
</div>
<div id="working-with-stan-directly" class="section level1">
<h1 class="hasAnchor">
<a href="#working-with-stan-directly" class="anchor"></a>Working with Stan directly</h1>
<p>So far, we have specified the models in brms and only used Stan implicitely behind the scenes. This allowed us to focus on the primary purpose of validating approximate LOO-CV for non-factorized models. However, we would also like to show how everything can be set up in Stan directly. The Stan code brms generates is human readable and so we can use it to learn some of the essential aspects of Stan and the particular model we are implementing. The Stan program below is a slightly modified version of the code extracted via <code><a href="https://rdrr.io/pkg/brms/man/stancode.brmsfit.html">stancode(fit_dummy)</a></code>:</p>
<div class="sourceCode" id="cb21"><html><body><pre class="r">// generated with brms 2.2.0
functions {
/**
 * Normal log-pdf for spatially lagged responses
 *
 * @param y Vector of response values.
 * @param mu Mean parameter vector.
 * @param sigma Positive scalar residual standard deviation.
 * @param rho Positive scalar autoregressive parameter.
 * @param W Spatial weight matrix.
 *
 * @return A scalar to be added to the log posterior.
 */
  real normal_lagsar_lpdf(vector y, vector mu, real sigma,
                          real rho, matrix W) {
    int N = rows(y);
    real inv_sigma2 = 1 / square(sigma);
    matrix[N, N] W_tilde = -rho * W;
    vector[N] half_pred;
    for (n in 1:N) W_tilde[n, n] += 1;
    half_pred = W_tilde * (y - mdivide_left(W_tilde, mu));
    return 0.5 * log_determinant(crossprod(W_tilde) * inv_sigma2) -
           0.5 * dot_self(half_pred) * inv_sigma2;
  }
}
data {
  int&lt;lower=1&gt; N;  // total number of observations
  vector[N] Y;  // response variable
  int&lt;lower=0&gt; Nmi;  // number of missings
  int&lt;lower=1&gt; Jmi[Nmi];  // positions of missings
  int&lt;lower=1&gt; K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  matrix[N, N] W;  // spatial weight matrix
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
  int Kc = K - 1;
  matrix[N, K - 1] Xc;  // centered version of X
  vector[K - 1] means_X;  // column means of X before centering
  for (i in 2:K) {
    means_X[i - 1] = mean(X[, i]);
    Xc[, i - 1] = X[, i] - means_X[i - 1];
  }
}
parameters {
  vector[Nmi] Ymi;  // estimated missings
  vector[Kc] b;  // population-level effects
  real temp_Intercept;  // temporary intercept
  real&lt;lower=0&gt; sigma;  // residual SD
  real&lt;lower=0,upper=1&gt; lagsar;  // SAR parameter
}
transformed parameters {
}
model {
  vector[N] Yl = Y;
  vector[N] mu = Xc * b + temp_Intercept;
  Yl[Jmi] = Ymi;
  // priors including all constants
  target += student_t_lpdf(temp_Intercept | 3, 34, 17);
  target += student_t_lpdf(sigma | 3, 0, 17)
    - 1 * student_t_lccdf(0 | 3, 0, 17);
  // likelihood including all constants
  if (!prior_only) {
    target += normal_lagsar_lpdf(Yl | mu, sigma, lagsar, W);
  }
}
generated quantities {
  // actual population-level intercept
  real b_Intercept = temp_Intercept - dot_product(means_X, b);
}</pre></body></html></div>
<p>Here we want to focus on two aspects of the Stan code. First, because there is no built-in function in Stan that calculates the log-likelihood for the lag-SAR model, we define a new <code>normal_lagsar_lpdf</code> function in the <code>functions</code> block of the Stan program. This is the same function we showed earlier in the vignette and it can be used to compute the log-likelihood in an efficient and numerically stable way. The <code>_lpdf</code> suffix used in the function name informs Stan that this is a log probability density function.</p>
<p>Second, this Stan program nicely illustrates how to set up missing value imputation. Instead of just computing the log-likelihood for the observed responses <code>Y</code>, we define a new variable <code>Yl</code> which is equal to <code>Y</code> if the reponse is observed and equal to <code>Ymi</code> if the response is missing. The latter is in turn defined as a parameter and thus estimated along with all other paramters of the model. More details about missing value imputation in Stan can be found in the <em>Missing Data &amp; Partially Known Parameters</em> section of the <a href="http://mc-stan.org/users/documentation/index.html">Stan manual</a>.</p>
<p>The Stan code extracted from brms is not only helpful when learning Stan, but can also drastically speed up the specification of models that are not support by brms. If brms can fit a model similar but not identical to the desired model, we can let brms generate the Stan program for the similar model and then mold it into the program that implements the model we actually want to fit. Rather than calling <code><a href="https://rdrr.io/pkg/brms/man/stancode.brmsfit.html">stancode()</a></code>, which requires an existing fitted model object, we recommend using <code><a href="https://rdrr.io/pkg/brms/man/make_stancode.html">make_stancode()</a></code> and specifying the <code>save_model</code> argument to write the Stan program to a file. The corresponding data can be prepared with <code><a href="https://rdrr.io/pkg/brms/man/make_standata.html">make_standata()</a></code> and then manually amended if needed. Once the code and data have been edited, they can be passed to RStan’s <code>stan()</code> function via the <code>file</code> and <code>data</code> arguments.</p>
</div>
<div id="conclusion" class="section level1">
<h1 class="hasAnchor">
<a href="#conclusion" class="anchor"></a>Conclusion</h1>
<p>In summary, we have shown how to set up and validate approximate and exact LOO-CV for non-factorized multivariate normal models using Stan with the <strong>brms</strong> and <strong>loo</strong> packages. Although we focused on the particular example of a spatial SAR model, the presented recipe applies more generally to models that can be expressed in terms of a multivariate normal likelihood.</p>
<p><br></p>
</div>
<div id="references" class="section level1">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<p>Anselin L. (1988). <em>Spatial econometrics: methods and models</em>. Dordrecht: Kluwer Academic.</p>
<p>Bürkner P. C., Gabry J., &amp; Vehtari A. (2020). Efficient leave-one-out cross-validation for Bayesian non-factorized normal and Student-t models. <a href="https://arxiv.org/abs/1810.10559">ArXiv preprint</a>.</p>
<p>Sundararajan S. &amp; Keerthi S. S. (2001). Predictive approaches for choosing hyperparameters in Gaussian processes. <em>Neural Computation</em>, 13(5), 1103–1118.</p>
<p>Vehtari A., Mononen T., Tolvanen V., Sivula T., &amp; Winther O. (2016). Bayesian leave-one-out cross-validation approximations for Gaussian latent variable models. <em>Journal of Machine Learning Research</em>, 17(103), 1–38. <a href="http://jmlr.org/papers/v17/14-540.html">Online</a>.</p>
<p>Vehtari A., Gelman A., &amp; Gabry J. (2017). Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC. <em>Statistics and Computing</em>, 27(5), 1413–1432. :10.1007/s11222-016-9696-4. <a href="http://link.springer.com/article/10.1007/s11222-016-9696-4">Online</a>. <a href="https://arxiv.org/abs/1507.04544">arXiv preprint arXiv:1507.04544</a>.</p>
<p>Vehtari, A., Simpson, D., Gelman, A., Yao, Y., and Gabry, J. (2019). Pareto smoothed importance sampling. <a href="https://arxiv.org/abs/1507.02646">arXiv preprint arXiv:1507.02646</a>.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Aki Vehtari, Jonah Gabry, Mans Magnusson, Yuling Yao, Paul-Christian Bürkner, Topi Paananen, Andrew Gelman.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.5.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
